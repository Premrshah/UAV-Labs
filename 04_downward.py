# -*- coding: utf-8 -*-
"""04_Downward.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dACCu2Ng9hAzfOonAblkxeL537kgyv5J
"""

# Commented out IPython magic to ensure Python compatibility.
from __future__ import print_function
# %matplotlib inline
import matplotlib.pyplot as plt
import numpy as np
import cv2
import glob
from matplotlib.patches import Rectangle
from scipy.stats import linregress
import matplotlib.patches as patches
from matplotlib.lines import Line2D

!git clone https://github.com/BWSI-UAV-2025/Week2_Vision.git

"""# Add your name below"""

# Fill in your name here
#Prem Shah

"""# Downward camera examples

This notebook contains several images taken from the downward camera on the drone, some of which observe the LED rope, others which do not, and even a couple of examples with one of the obstacles partially blocking the view of the LED rope.
"""

downward = glob.glob("/content/Week2_Vision/notebooks/downward/*.jpg")
downward.sort()
downward = [cv2.imread(s, cv2.IMREAD_GRAYSCALE) for s in downward]
print( "{} downward images in dataset".format(len(downward)))

fig, ax = plt.subplots(ncols=2, nrows=len(downward)//2)
[a.axis('off') for a in ax.flatten()]

for d,a in zip(downward, ax.flatten()):
    a.imshow(d, cmap='gray')

fig.set_size_inches(10,28);

"""# Image Analysis: moving beyond linear regression

## Contour Analysis

You will have to implement more image processing routines beyond linear regression in order to handle several edge cases onboard the drone.

Consider a reflection (from the ceiling lights or the sun) which causes a bright spot in the image at a different position from the LED rope:

![image.png](attachment:image.png)

This condition represents an **outlier** - the regressed line will be "pulled" in the direction of the outlier, and not sit directly on the LED rope. One remedy for designing an outlier-robust line detector is to apply some *image morphology* plus *contour analysis.*

For instance, you can use **dilation** in order to connect the individual LED bulbs together into a single contour, and then regress a line through the largest contour found.

# Contour Analysis in OpenCV

The first two tutorials are very helpful to read through for completing this lab exercise (and the rest of the tutorials on contour analysis are linked below, and also worth reading for future reference in the course).

1. https://docs.opencv.org/3.3.1/d4/d73/tutorial_py_contours_begin.html
1. https://docs.opencv.org/3.3.1/dd/d49/tutorial_py_contour_features.html
1. https://docs.opencv.org/3.3.1/d3/d05/tutorial_py_table_of_contents_contours.html

Another example where contour analysis can help is deciding whether or not enough of the line is **visibile** in order to correctly compute a direction in which to fly the drone. Consider the two examples below. Arguably, not enough of the line is visible in the second example to correctly compute a flight direction. (In fact, you might instead want to ensure the line stretches across the entire image, and if not, hover the drone in place.)

![image.png](attachment:image.png)

![image.png](attachment:image.png)

Furthermore, note that applying linear regression on an individal contour is not a panacea to outliers, and indeed, it can lead to undesirable results. In the example below, there is an obstacle sitting above the LED rope. Thus, the largest contour found will not contain the entire LED rope.

You might thus want to use contour analysis to determine that yes, enough of the LED rope is visible to compute a valid velocity command for the drone (by inspecting the width and height of the contour), but then perform linear regression on the entire (thresholded) image, rather than only on the largest contour found. Alternatively, you might want to consider multiple contours. There are many strategies available to choose from. This is part of the design exercise that your team will proceed through.

![image.png](attachment:image.png)

# Morphology

As a final example of "contour analysis gone wrong," observe that the largest contour found in the below image does not contain the entire LED rope - it only contains a couple of individual LED bulbs. This is a case in which **dilation, erosion, opening** or other morphological operations can greatly benefit your image processing pipeline, e.g., by "closing the gaps" between each LED bulb.

![image.png](attachment:image.png)

# Your task

Process all of the images in this small dataset. For each image, write code to detect whether it contains enough of the line to justify further processing (or no line at all), and if your algorithm decides it does contain a sufficient enough portion of the LED rope, plot the regressed line on top of the image.

Using contour analysis for this task is certainly not required (there are many ways you could tackle this problem), but it's a good place to start!

Note that you may need to tune your thresholding algorithm. Several images in the dataset also contain gray floor tiles, which should *not* be detect as white LED pixels.

# Stretch goals:

You now have implemented linear regression on your own. Compare your answers on all of the above images with two "off-the-shelf" python functions (one from OpenCV, another from scipy) which implement linear regression. Visualize the outputs of both functions, alongside your own implementation from the Linear Regression notebook.

**OpenCV:**

```python
cv2.fitLine()
```

**Scipy:**

```python
from scipy.stats import linregress
```
"""

def calculate_regression(points): # input is the result of np.argwhere
    # convert points to float

    points = points.astype(float)
    xs = points[:,1] #TODO
    ys = points[:,0] #TODO
    x_mean = np.average(xs) #TODO
    y_mean = np.average(ys) #TODO

    xy_mean = np.mean(np.multiply(xs, ys)) #TODO

    x_squared_mean = np.mean([x**2 for x in xs]) #TODO

    m = (x_mean * y_mean - xy_mean)/(x_mean ** 2 - x_squared_mean) #TODO

    b = y_mean - m * x_mean #TODO

    return (m,b)



def find_inliers(m, b, shape):
    y_max = shape[0]
    x_max = shape[1]

    for i in range(x_max):
      y = m*i+b
      if y < y_max:
        x1 = i
        y1 = y
        break

    for i in range(x_max-1,0,-1):
      y = m*i+b
      if y < y_max:
        x2 = i
        y2 = y
        break

    return x1, y1, x2, y2

image = downward[12]
plt.imshow(image, cmap = 'gray')

_, image = cv2.threshold(image,245,255,cv2.THRESH_BINARY)
plt.imshow(image, cmap = 'gray')

kernel = np.ones((5,5), np.uint8)
dilation = cv2.dilate(image,kernel,iterations = 3)
plt.imshow(dilation)

m,b = calculate_regression(np.argwhere(dilation))
x1, y1, x2, y2 = find_inliers(m,b, dilation.shape)
fig,ax = plt.subplots()
ax.imshow(dilation, cmap='gray');
regression = Line2D([x1,x2],[y1,y2], color='lime')
ax.add_line(regression);

for image in downward:
  _, image = cv2.threshold(image,245,255,cv2.THRESH_BINARY)
  white_pixel_count = np.sum(image == 255)
  print(white_pixel_count)
  if (white_pixel_count > 250):
    kernel = np.ones((5,5), np.uint8)
    dilation = cv2.dilate(image,kernel,iterations = 3)
    m,b = calculate_regression(np.argwhere(dilation))
    x1, y1, x2, y2 = find_inliers(m,b, dilation.shape)
    fig,ax = plt.subplots()
    ax.imshow(image, cmap='gray');
    regression = Line2D([x1,x2],[y1,y2], color='lime')
    ax.add_line(regression)
  else:
    print("Not enough of line detected")
    plt.imshow(image)

"""## When you are done

You should have all sixteen images processed, some with regression lines plotted on top of them, others detected as not containing a line (or not containing enough of the line).

1. Double-check that you filled in your name at the top of the notebook!
2. Click `File` -> `Export Notebook As` -> `PDF`
3. Email the PDF to `YOURTEAMNAME@beaver.works`
"""